<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>元数据配置 | easysql</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="类型安全的查询构造器，orm">
    
    <link rel="preload" href="/easysql-doc/assets/css/0.styles.e413b544.css" as="style"><link rel="preload" href="/easysql-doc/assets/js/app.043c89df.js" as="script"><link rel="preload" href="/easysql-doc/assets/js/2.ebde4dba.js" as="script"><link rel="preload" href="/easysql-doc/assets/js/12.1019e624.js" as="script"><link rel="prefetch" href="/easysql-doc/assets/js/10.755206bb.js"><link rel="prefetch" href="/easysql-doc/assets/js/11.108365c7.js"><link rel="prefetch" href="/easysql-doc/assets/js/13.eaad68f3.js"><link rel="prefetch" href="/easysql-doc/assets/js/14.ebdb112e.js"><link rel="prefetch" href="/easysql-doc/assets/js/15.16c963a1.js"><link rel="prefetch" href="/easysql-doc/assets/js/16.b981116c.js"><link rel="prefetch" href="/easysql-doc/assets/js/17.8b6320d9.js"><link rel="prefetch" href="/easysql-doc/assets/js/3.8dfc125c.js"><link rel="prefetch" href="/easysql-doc/assets/js/4.13b745f6.js"><link rel="prefetch" href="/easysql-doc/assets/js/5.54501c54.js"><link rel="prefetch" href="/easysql-doc/assets/js/6.45f8a5ad.js"><link rel="prefetch" href="/easysql-doc/assets/js/7.4e2227f1.js"><link rel="prefetch" href="/easysql-doc/assets/js/8.fc49f0b8.js"><link rel="prefetch" href="/easysql-doc/assets/js/9.27ab6d13.js">
    <link rel="stylesheet" href="/easysql-doc/assets/css/0.styles.e413b544.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/easysql-doc/" class="home-link router-link-active"><!----> <span class="site-name">easysql</span></a> <div class="links"><!----> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/easysql-doc/" aria-current="page" class="sidebar-link">概述</a></li><li><a href="/easysql-doc/introduction/" class="sidebar-link">入门</a></li><li><a href="/easysql-doc/metadata/" aria-current="page" class="active sidebar-link">元数据配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/easysql-doc/metadata/#基础配置" class="sidebar-link">基础配置</a></li><li class="sidebar-sub-header"><a href="/easysql-doc/metadata/#元数据的细节" class="sidebar-link">元数据的细节</a></li></ul></li><li><a href="/easysql-doc/expr/" class="sidebar-link">表达式</a></li><li><a href="/easysql-doc/select/" class="sidebar-link">查询</a></li><li><a href="/easysql-doc/query/" class="sidebar-link">集合函数风格查询</a></li><li><a href="/easysql-doc/jpa/" class="sidebar-link">JPA风格查询</a></li><li><a href="/easysql-doc/update/" class="sidebar-link">增删改</a></li><li><a href="/easysql-doc/native-sql/" class="sidebar-link">原生sql</a></li><li><a href="/easysql-doc/database/" class="sidebar-link">数据库交互</a></li><li><a href="/easysql-doc/nosql/" class="sidebar-link">nosql支持</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="元数据配置"><a href="#元数据配置" class="header-anchor">#</a> 元数据配置</h1> <p>在大多数应用中，我们需要预先对数据表进行建模，创建数据库实体类，easysql支持从实体类中进行元数据抽取。</p> <p>如果你的需求是动态构建报表查询，并不能事先对表结构建模，可以先跳过此部分，后续部分将会介绍如何使用动态的表名和字段名来构造查询。</p> <h2 id="基础配置"><a href="#基础配置" class="header-anchor">#</a> 基础配置</h2> <p>下面有一个<code>case class</code>组织的实体类, 可空字段使用<code>Option</code>类型：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>我们可以在类上添加注解<code>Table</code>（可以省略），在字段上添加注解<code>Column</code>（可以省略），主键字段添加<code>PrimaryKey</code>或<code>IncrKey</code>（对应自增主键）：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token annotation punctuation">@Table</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span><span class="token annotation punctuation">@IncrKey</span> id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">&quot;user_name&quot;</span><span class="token punctuation">)</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>注解的参数为实际的数据库表名或字段名，如果代码中的名字与数据库中的名字符合驼峰命名转到蛇形命名的映射关系，则可以省略。</p> <p>如果想自定义主键的生成策略，在<code>PrimaryKeyGenerator</code>注解中填写一个高阶函数即可，以java标准库中的UUID为例：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token annotation punctuation">@Table</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span>
    <span class="token annotation punctuation">@PrimaryKeyGenerator</span><span class="token punctuation">(</span><span class="token string">&quot;user_id&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> UUID<span class="token punctuation">.</span>randomUUID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> 
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">&quot;user_name&quot;</span><span class="token punctuation">)</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre></div><p>然后使用<code>asTable</code>来从实体类中生成表的代理对象，后续的大多数查询操作都要使用这个对象：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token annotation punctuation">@Table</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span><span class="token annotation punctuation">@IncrKey</span> id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">&quot;user_name&quot;</span><span class="token punctuation">)</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">val</span> user <span class="token operator">=</span> asTable<span class="token punctuation">[</span>User<span class="token punctuation">]</span>
</code></pre></div><p><code>asTable</code>会将实体类转换为<code>TableSchema</code>表结构信息，这样我们就能用这些元数据来构造查询了：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token comment">// 查询</span>
<span class="token keyword">val</span> s <span class="token operator">=</span> select <span class="token punctuation">(</span>user<span class="token punctuation">)</span> from user where user<span class="token punctuation">.</span>id <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment">// 增删改</span>
<span class="token keyword">val</span> userRow <span class="token operator">=</span> User<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;x&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> i <span class="token operator">=</span> insert<span class="token punctuation">(</span>userRow<span class="token punctuation">)</span>
<span class="token keyword">val</span> u <span class="token operator">=</span> update<span class="token punctuation">(</span>userRow<span class="token punctuation">)</span>
<span class="token keyword">val</span> sv <span class="token operator">=</span> save<span class="token punctuation">(</span>userRow<span class="token punctuation">)</span>
<span class="token keyword">val</span> d <span class="token operator">=</span> delete<span class="token punctuation">[</span>User<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>有些时候，我们需要在实体类中放入一些自定义的类型，比如状态的枚举，为了让easysql知晓如何正确生成查询，并把查询结果反序列化到实体类，我们需要做一些额外的配置：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">enum</span> State <span class="token punctuation">{</span>
    <span class="token keyword">case</span> Open
    <span class="token keyword">case</span> Close
<span class="token punctuation">}</span>

<span class="token keyword">object</span> StateSerializer <span class="token keyword">extends</span> CustomSerializer<span class="token punctuation">[</span>State<span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">def</span> toValue<span class="token punctuation">(</span>x<span class="token operator">:</span> State<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> x <span class="token keyword">match</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> State<span class="token punctuation">.</span>Open <span class="token keyword">=&gt;</span> <span class="token number">1</span>
        <span class="token keyword">case</span> State<span class="token punctuation">.</span>Close <span class="token keyword">=&gt;</span> <span class="token number">2</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">def</span> fromValue<span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span><span class="token operator">:</span> State <span class="token operator">=</span> x <span class="token keyword">match</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">1</span> <span class="token keyword">=&gt;</span> State<span class="token punctuation">.</span>Open
        <span class="token keyword">case</span> _ <span class="token keyword">=&gt;</span> State<span class="token punctuation">.</span>Close
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span>
    <span class="token annotation punctuation">@IncrKey</span> id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> 
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">&quot;user_name&quot;</span><span class="token punctuation">)</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span>
    <span class="token annotation punctuation">@CustomColumn</span><span class="token punctuation">(</span><span class="token string">&quot;state&quot;</span><span class="token punctuation">,</span> StateSerializer<span class="token punctuation">)</span> state<span class="token operator">:</span> State
<span class="token punctuation">)</span>

<span class="token keyword">val</span> user <span class="token operator">=</span> asTable<span class="token punctuation">[</span>User<span class="token punctuation">]</span>
</code></pre></div><p>我们需要编写一个object，继承<code>CustomSerializer</code>，第一个类型参数为自定义的类型，第二个类型参数为表的字段类型，并填写用来生成sql的<code>toValue</code>方法和用于反序列化的<code>fromValue</code>方法。</p> <p>最后，在实体类中的自定义类型字段上添加注解<code>CustomColumn</code>，easysql会从注解信息中尽力生成类型安全的表结构信息。</p> <blockquote><p>更详细的查询构造方法会在后文查询构造部分介绍。</p></blockquote> <h2 id="元数据的细节"><a href="#元数据的细节" class="header-anchor">#</a> 元数据的细节</h2> <p>如果我们有这样两个实体类，并为其生成表结构的元数据信息：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token annotation punctuation">@Table</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span><span class="token annotation punctuation">@IncrKey</span> id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> user <span class="token operator">=</span> asTable<span class="token punctuation">[</span>User<span class="token punctuation">]</span>

<span class="token annotation punctuation">@Table</span>
<span class="token keyword">case</span> <span class="token keyword">class</span> Post<span class="token punctuation">(</span><span class="token annotation punctuation">@IncrKey</span> id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> userId<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> Option<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> post <span class="token operator">=</span> asTable<span class="token punctuation">[</span>Post<span class="token punctuation">]</span>
</code></pre></div><p>easysql会读取实体类的类型信息和注解信息，使用<strong>结构类型</strong>，生成实际的元数据代理信息，上面两个表结构的实际类型信息为：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">val</span> user<span class="token operator">:</span> TableSchema<span class="token punctuation">[</span>User<span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> id<span class="token operator">:</span> PrimaryKeyExpr<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">]</span> 
    <span class="token keyword">val</span> name<span class="token operator">:</span> ColumnExpr<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> post<span class="token operator">:</span> TableSchema<span class="token punctuation">[</span>Post<span class="token punctuation">]</span> <span class="token punctuation">{</span> 
    <span class="token keyword">val</span> id<span class="token operator">:</span> PrimaryKeyExpr<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">]</span> 
    <span class="token keyword">val</span> userId<span class="token operator">:</span> ColumnExpr<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token string">&quot;userId&quot;</span><span class="token punctuation">]</span> 
    <span class="token keyword">val</span> name<span class="token operator">:</span> ColumnExpr<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然我们可以使用Scala3的类型推断功能，不必显式写出生成的类型，但是了解easysql代理出的类型仍然是有意义的。</p> <p>比如，我们可以给不同的查询添加上相同的sql片段（通常是为了处理逻辑删除标记、记录数据更新时间等）：</p> <div class="language-scala extra-class"><pre class="language-scala"><code><span class="token keyword">inline</span> <span class="token keyword">def</span> filterId<span class="token punctuation">[</span>T <span class="token operator">&lt;</span><span class="token operator">:</span> Product<span class="token punctuation">]</span><span class="token punctuation">(</span>table<span class="token operator">:</span> TableSchema<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">val</span> id<span class="token operator">:</span> PrimaryKeyExpr<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    select <span class="token punctuation">(</span>table<span class="token punctuation">)</span> from table where table<span class="token punctuation">.</span>id <span class="token operator">&gt;</span> <span class="token number">0</span>

<span class="token keyword">val</span> userQuery <span class="token operator">=</span> filterId<span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token keyword">val</span> postQuery <span class="token operator">=</span> filterId<span class="token punctuation">(</span>post<span class="token punctuation">)</span>
</code></pre></div><p>使用<strong>结构类型</strong>约束参数的字段信息，即可做到这一点。需要注意的是，<code>TableSchema</code>的泛型参数上界为<code>Product</code>，并且这样的共用方法需要使用<code>inline</code>标记。</p> <p>关于<strong>结构类型</strong>的更多信息，可以自行查看Scala3的官方文档。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/easysql-doc/introduction/" class="prev">
        入门
      </a></span> <span class="next"><a href="/easysql-doc/expr/">
        表达式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/easysql-doc/assets/js/app.043c89df.js" defer></script><script src="/easysql-doc/assets/js/2.ebde4dba.js" defer></script><script src="/easysql-doc/assets/js/12.1019e624.js" defer></script>
  </body>
</html>
